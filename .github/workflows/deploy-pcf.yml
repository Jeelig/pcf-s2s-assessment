name: Deploy PCF to Environment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Power Platform Environment'
        required: true
        type: choice
        options:
          - DEV-X
          - DEV-1
          - DEV-7
      search_string:
        description: 'PCF version (ex: 1.4.52)'
        required: true
        default: '1.4.52'

jobs:
  find-artifact:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read  # Nécessaire pour lister les runs et artéfacts
    outputs:
      run_id: ${{ steps.find.outputs.run_id }}
      artifact_id: ${{ steps.find.outputs.artifact_id }}
      artifact_name: ${{ steps.find.outputs.artifact_name }}
    steps:
      - name: Vérifier les entrées
        run: |
          echo "Workflow fichier : build.yml"
          echo "Recherche dans artéfacts : '${{ inputs.search_string }}'"

      - name: Récupérer l'ID du workflow
        id: get-workflow-id
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          WORKFLOW_FILE="build.yml"
          echo "Récupération de l'ID du workflow : $WORKFLOW_FILE"

          gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/actions/workflows" \
            --jq ".workflows[] | select(.path == \".github/workflows/$WORKFLOW_FILE\") | .id" > workflow_id.txt

          WORKFLOW_ID=$(cat workflow_id.txt)

          if [ -z "$WORKFLOW_ID" ] || [ "$WORKFLOW_ID" = "null" ]; then
            echo "❌ Workflow non trouvé : $WORKFLOW_FILE"
            exit 1
          fi

          echo "✅ Workflow ID = $WORKFLOW_ID"
          echo "workflow_id=$WORKFLOW_ID" >> $GITHUB_OUTPUT

      - name: Lister les runs du workflow
        id: list-runs
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          WORKFLOW_ID="${{ steps.get-workflow-id.outputs.workflow_id }}"
          echo "Liste des 50 derniers runs du workflow ID $WORKFLOW_ID..."

          gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/actions/workflows/$WORKFLOW_ID/runs?per_page=50" \
            --jq '.workflow_runs[] | {id, status, conclusion, artifacts_url}' > runs.json

      - name: Lister les runs du workflow
        run: |
          gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/actions/workflows/build.yml/runs?per_page=50&status=completed" \
            > runs.json
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Chercher un artéfact contenant la chaîne
        id: find
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          SEARCH_STRING: ${{ inputs.search_string }}
        shell: python
        run: |
          import json, os, re, sys, urllib.request

          search = os.environ['SEARCH_STRING'].lower()
          output = os.environ['GITHUB_OUTPUT']

          raw = open("runs.json","r").read()
          print("DEBUG RAW JSON (premières 300 chars) -->")
          print(raw[:300])

          # Extraire le premier payload JSON valide (souvent gh ajoute du spam ligne 1)
          match = re.search(r'(\{.*\})', raw, re.DOTALL)
          if not match:
              print("Pas de JSON détecté.")
              sys.exit(1)

          data = json.loads(match.group(1))

          runs = data.get("workflow_runs", [])
          print(f"Total runs analysés: {len(runs)}")

          found = False

          for run in runs:
              run_id = run['id']
              url = run['artifacts_url']

              req = urllib.request.Request(url, headers={
                  "Authorization": f"token {os.environ['GH_TOKEN']}",
                  "Accept": "application/vnd.github+json"
              })

              try:
                data_art = json.loads(urllib.request.urlopen(req).read().decode())
              except Exception as e:
                print(f"Erreur API run {run_id} : {e}")
                continue

              for a in data_art.get("artifacts",[]):
                  if search in a['name'].lower():
                      with open(output,"a") as gh:
                          gh.write(f"run_id={run_id}\n")
                          gh.write(f"artifact_id={a['id']}\n")
                          gh.write(f"artifact_name={a['name']}\n")
                      print("ARTÉFACT TROUVÉ ✅")
                      print(a)
                      found = True
                      break
              if found: break

          if not found:
              print(f"Aucun artéfact ne contient '{search}'")
              sys.exit(1)

      - name: Checkout repo (obligatoire pour gh run download)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Télécharger l'artéfact source du run trouvé
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          echo "Téléchargement de l'artéfact…"
          gh run download ${{ steps.find.outputs.run_id }} \
            --name "${{ steps.find.outputs.artifact_name }}" \
            --dir ./pcf-artifact

      - name: Supprimer la version managed
        run: |
          echo "Suppression des zip managed..."
          find ./pcf-artifact -type f -name "*managed*.zip" -delete

      - name: Uploader l'artéfact dans le run actuel
        uses: actions/upload-artifact@v4
        with:
          name: pcf-found-${{ inputs.search_string }}
          path: ./pcf-artifact
          retention-days: 7

  deploy-to-env:
    needs: find-artifact
    runs-on: windows-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read

    steps:
      - name: Télécharger l'artéfact récupéré
        uses: actions/download-artifact@v4
        with:
          name: pcf-found-${{ inputs.search_string }}
          path: ./deploy-folder

      - name: Supprimer version managed
        shell: pwsh
        run: |
          Get-ChildItem "./deploy-folder" -Filter "*managed*.zip" | Remove-Item -Force
    
      - name: Déterminer l'URL de l'environnement
        id: resolve-env
        shell: bash
        run: |
          case "${{ inputs.environment }}" in DEV)
              echo "env_url=https://org-dev.crm4.dynamics.com" >> $GITHUB_OUTPUT
              ;;
            UAT)
              echo "env_url=https://org-uat.crm4.dynamics.com" >> $GITHUB_OUTPUT
              ;;
            PREPROD)
              echo "env_url=https://org-preprod.crm4.dynamics.com" >> $GITHUB_OUTPUT
              ;;
            PROD)
              echo "env_url=https://org.crm4.dynamics.com" >> $GITHUB_OUTPUT
              ;;
          esac
    
      - name: Installer .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '6.0.x'

      - name: Installer Power Platform CLI via NuGet
        shell: pwsh
        run: |
          nuget install Microsoft.PowerApps.CLI -Source https://api.nuget.org/v3/index.json -OutputDirectory "$env:USERPROFILE\pac"
          $pacPath = Get-ChildItem "$env:USERPROFILE\pac\Microsoft.PowerApps.CLI*" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          $toolsPath = Join-Path $pacPath.FullName "tools"
          echo "$toolsPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Connexion au tenant Power Platform
        shell: pwsh
        env:
          CLIENT_ID: ${{ secrets.PP_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.PP_CLIENT_SECRET }}
          TENANT_ID: ${{ secrets.PP_TENANT_ID }}
          ENV_URL: ${{ secrets.PP_ENV_URL }}
        run: |
          pac auth create --url "$env:ENV_URL" --tenant "$env:TENANT_ID" --applicationId "$env:CLIENT_ID" --clientSecret "$env:CLIENT_SECRET"
          pac org who

      - name: Import solution PCF
        shell: pwsh
        run: |
          $zip = Get-ChildItem "./deploy-folder" -Filter "*.zip" | Select-Object -First 1
          Write-Host "Importing: $($zip.FullName)"
          pac solution import --path "$($zip.FullName)" --force-overwrite --publish-changes
